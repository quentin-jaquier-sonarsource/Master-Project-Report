\section{Limitation of the approach: Anticipating other potential problems}
\label{sec:anticipating_problems}

In the previous parts, we have shown that we were able, with some assumptions, to find with \slang all the issues found by the implementation on SonarJava. 
This is encouraging, but it does not implies that nothing is lost during with this approach.
In this part, we will try to briefly anticipate problems that were not central to this checker, but might come later, by first focusing on Kotlin example, then well known language features.

\subsection{Kotlin}
\label{subsec:kotlin}

\lstinputlisting[label={lst:false-positive-kotlin},
caption=Kotlin code that raise a false positive]{code/false-positive-kotlin.scala}

Listing \ref{lst:false-positive-kotlin} shows Kotlin code with an interesting situation. 
At line $\#3$, we can see that the function \emph{isBooleanOrInt} from the pointer \emph{a} is called without a safe call with \emph{.?}. 
Normally, the type system of Kotlin prevent this kind of issue if the variable is nullable (of type \emph{Any?}). 
However this code will not raise a null pointer exception since in fact the function \emph{isBooleanOrInt} is called, without dereferencing the pointer \emph{a}! 
Our checker is only checking the content of one function, from his point of view this code can raise an exception. 
This is clearly a false positive that is reported in for Kotlin. 
In fact, in Kotlin, we do not expect to find any situations where an exception is possible, but only issues that are dead code, as described in section \ref{subsubsec:dead_code}.

\subsection{Other languages features}
\label{subsec:other_language_features}

\begin{enumerate}
	\item \textit{Call by name or by value} \newline
	\lstinputlisting[label={lst:call-by-name-or-value},
	caption=Difference between call by name and by value]{code/call-by-name-or-value.scala}
	
	Listing \ref{lst:call-by-name-or-value} shows pseudo code that demonstrate the potential problematic question. If the language uses call by value, the code will raise a null pointer exception, however, if we use a call by name, p2 will not be evaluated and therefore nothing wrong happen. \newline
	\item \textit{Functional language} \newline
	\item \textit{closure/high order function} \newline
	\item \textit{Static vs dynamic scoping} \newline
	\item \textit{Static vs dynamic typing} \newline
	\item \textit{Declarative vs imperative language} \newline
\end{enumerate}

\subsection{How can SLang cope with all these feature ?}
\label{subsec:how_can_slang_cope_with_features}

All these feature are finally concretely related to the same challenge: choose what we want to add in \slang. 
We can always add more feature, but the language will quickly become very complex and unmaintainable. For example for the call by name/value, we can easily add the information in the node, and use this information in the checker. 
There is not clear answer, it is all about the tradeoff discussed in section \ref{subsubsec:precision_recall}, if one feature seems to be appearing a lot and causing problems, it would make sense to include it in the grammar.
