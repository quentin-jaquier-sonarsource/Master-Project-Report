\section{Limitation of the approach: Anticipating other potential problems}
\label{sec:anticipating_problems}
[TODO: This part still need a rework...] \newline
In the previous parts, we have shown that we were able, with some assumptions, to find with \slang{} all the issues found by the implementation on SonarJava. 
This is encouraging, but it does not implies that nothing is lost during with this approach.
In this part, we will try to briefly anticipate problems that were not central to this checker, but might come later.

\subsection{Languages features}
\label{subsec:other_language_features}

The goal of this section is to presents other potential problems that can arise due to different languages features. We are going to present a high level overview of the feature, and not precisely describe an exhaustive list of the consequences and how to deal with these.
This list is particularly useful when thinking about new rules that we can add to \slang, being aware of them can help to avoid bad surprises.

\begin{enumerate}
	\item \textit{Call by name or by value} \newline
	\lstinputlisting[label={lst:call-by-name-or-value},
	caption=Difference between call by name and by value]{code/call-by-name-or-value.scala}
	
	Listing \ref{lst:call-by-name-or-value} shows pseudo code that demonstrate the potential problematic question. If the language uses call by value, the code will raise a \emph{null} pointer exception, however, if we use a call by name, \emph{p2} will not be evaluated and therefore nothing wrong happen. \newline
	\item \textit{Functional language} \newline
	In subsection \ref{subsec:concrete_example}, we have described the addition of a new language on top of \slang{}.
	Adding a functional language does bring additional challenges, but supporting the current rules implemented on \slang{} has been done without blockers. \newline
	One typical feature of functional language that we are going to face one day or an other are the high order functions.
	\begin{enumerate}
		\item \textit{closure/high order function} \newline
	\end{enumerate}

	\item \textit{Static vs dynamic scoping} \newline
	\item \textit{Static vs dynamic typing} \newline
	\item \textit{Declarative vs imperative language} \newline
\end{enumerate}

\subsection{How can SLang cope with all these feature ?}
\label{subsec:how_can_slang_cope_with_features}

All these feature are concretely related to the same challenge: choose what we want to add in \slang{}. 
We can always add more feature, but the language will quickly become very complex and unmaintainable. For example for the call by name/value, we can easily add the information in the node, and use this information in the checker. 
There is not clear answer, it is all about the tradeoff discussed in section \ref{subsubsec:precision_recall}, if one feature seems to be appearing a lot and causing problems, it would make sense to include it in the grammar.
